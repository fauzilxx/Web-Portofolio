document.addEventListener('DOMContentLoaded', () => {
    // ============================================
    // Target Cursor
    // ============================================
    class TargetCursor {
        constructor(options = {}) {
            this.targetSelector = options.targetSelector || '.cursor-target';
            this.spinDuration = options.spinDuration || 2;
            this.hideDefaultCursor = options.hideDefaultCursor !== false;
            this.hoverDuration = options.hoverDuration || 0.2;
            this.parallaxOn = options.parallaxOn !== false;
            
            this.cursor = document.getElementById('target-cursor');
            this.dot = document.getElementById('cursor-dot');
            this.corners = null;
            
            this.spinTl = null;
            this.isActive = false;
            this.targetCornerPositions = null;
            this.activeStrength = 0;
            this.activeTarget = null;
            this.currentLeaveHandler = null;
            this.resumeTimeout = null;
            
            this.constants = {
                borderWidth: 3,
                cornerSize: 12
            };
            
            this.isMobile = this.detectMobile();
            
            if (!this.isMobile && this.cursor) {
                this.init();
            }
        }
        
        detectMobile() {
            const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const isSmallScreen = window.innerWidth <= 768;
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;
            const isMobileUserAgent = mobileRegex.test(userAgent.toLowerCase());
            return (hasTouchScreen && isSmallScreen) || isMobileUserAgent;
        }
        
        init() {
            // Show cursor dot always for tracking, but hide corners initially
            this.cursor.style.opacity = '1';
            
            this.corners = this.cursor.querySelectorAll('.target-cursor-corner');
            
            // Hide corners initially
            Array.from(this.corners).forEach(corner => {
                gsap.set(corner, { opacity: 0 });
            });
            
            gsap.set(this.cursor, {
                xPercent: -50,
                yPercent: -50,
                x: window.innerWidth / 2,
                y: window.innerHeight / 2
            });
            
            this.createSpinTimeline();
            this.attachEventListeners();
        }
        
        createSpinTimeline() {
            if (this.spinTl) {
                this.spinTl.kill();
            }
            this.spinTl = gsap.timeline({ repeat: -1 })
                .to(this.cursor, { rotation: '+=360', duration: this.spinDuration, ease: 'none' });
        }
        
        moveCursor(x, y) {
            if (!this.cursor) return;
            gsap.to(this.cursor, {
                x,
                y,
                duration: 0.1,
                ease: 'power3.out'
            });
        }
        
        tickerFn() {
            if (!this.targetCornerPositions || !this.cursor || !this.corners) return;
            
            const strength = this.activeStrength;
            if (strength === 0) return;
            
            const cursorX = gsap.getProperty(this.cursor, 'x');
            const cursorY = gsap.getProperty(this.cursor, 'y');
            
            Array.from(this.corners).forEach((corner, i) => {
                const currentX = gsap.getProperty(corner, 'x');
                const currentY = gsap.getProperty(corner, 'y');
                const targetX = this.targetCornerPositions[i].x - cursorX;
                const targetY = this.targetCornerPositions[i].y - cursorY;
                const finalX = currentX + (targetX - currentX) * strength;
                const finalY = currentY + (targetY - currentY) * strength;
                const duration = strength >= 0.99 ? (this.parallaxOn ? 0.2 : 0) : 0.05;
                
                gsap.to(corner, {
                    x: finalX,
                    y: finalY,
                    duration: duration,
                    ease: duration === 0 ? 'none' : 'power1.out',
                    overwrite: 'auto'
                });
            });
        }
        
        cleanupTarget(target) {
            if (this.currentLeaveHandler) {
                target.removeEventListener('mouseleave', this.currentLeaveHandler);
            }
            this.currentLeaveHandler = null;
        }
        
        handleEnter(e) {
            const directTarget = e.target;
            const allTargets = [];
            let current = directTarget;
            
            while (current && current !== document.body) {
                if (current.matches(this.targetSelector)) {
                    allTargets.push(current);
                }
                current = current.parentElement;
            }
            
            const target = allTargets[0] || null;
            if (!target || !this.cursor || !this.corners) return;
            if (this.activeTarget === target) return;
            
            if (this.activeTarget) {
            // Show custom cursor and hide default cursor
            gsap.to(this.cursor, { opacity: 1, duration: 0.2 });
            if (this.hideDefaultCursor) {
                document.body.style.cursor = 'none';
            }
            
                this.cleanupTarget(this.activeTarget);
            }
            
            if (this.resumeTimeout) {
                clearTimeout(this.resumeTimeout);
                this.resumeTimeout = null;
            }
            
            this.activeTarget = target;
            
            Array.from(this.corners).forEach(corner => gsap.killTweensOf(corner));
            gsap.killTweensOf(this.cursor, 'rotation');
            this.spinTl?.pause();
            gsap.set(this.cursor, { rotation: 0 });
            
            const rect = target.getBoundingClientRect();
            const { borderWidth, cornerSize } = this.constants;
            const cursorX = gsap.getProperty(this.cursor, 'x');
            const cursorY = gsap.getProperty(this.cursor, 'y');
            
            this.targetCornerPositions = [
                { x: rect.left - borderWidth, y: rect.top - borderWidth },
                { x: rect.right + borderWidth - cornerSize, y: rect.top - borderWidth },
                { x: rect.right + borderWidth - cornerSize, y: rect.bottom + borderWidth - cornerSize },
                { x: rect.left - borderWidth, y: rect.bottom + borderWidth - cornerSize }
            ];
            
            this.isActive = true;
            gsap.ticker.add(() => this.tickerFn());
            
            gsap.to(this, { activeStrength: 1, duration: this.hoverDuration, ease: 'power2.out' });
            
            Array.from(this.corners).forEach((corner, i) => {
                gsap.to(corner, {
                    x: this.targetCornerPositions[i].x - cursorX,
                    y: this.targetCornerPositions[i].y - cursorY,
                    duration: 0.2,
                    ease: 'power2.out'
                });
            });
            
            const leaveHandler = () => {
                // Hide corners and restore default cursor
                if (this.corners) {
                    Array.from(this.corners).forEach(corner => {
                        gsap.to(corner, { opacity: 0, duration: 0.2 });
                    });
                }
                
                if (this.hideDefaultCursor) {
                    document.body.style.cursor = '';
                }
                
                gsap.ticker.remove(() => this.tickerFn());
                this.isActive = false;
                this.targetCornerPositions = null;
                this.activeStrength = 0;
                this.activeTarget = null;
                
                if (this.corners) {
                    const corners = Array.from(this.corners);
                    gsap.killTweensOf(corners);
                    const { cornerSize } = this.constants;
                    const positions = [
                        { x: -cornerSize * 1.5, y: -cornerSize * 1.5 },
                        { x: cornerSize * 0.5, y: -cornerSize * 1.5 },
                        { x: cornerSize * 0.5, y: cornerSize * 0.5 },
                        { x: -cornerSize * 1.5, y: cornerSize * 0.5 }
                    ];
                    
                    corners.forEach((corner, index) => {
                        gsap.to(corner, { 
                            x: positions[index].x, 
                            y: positions[index].y, 
                            duration: 0.3, 
                            ease: 'power3.out' 
                        });
                    });
                }
                
                this.resumeTimeout = setTimeout(() => {
                    if (!this.activeTarget && this.cursor && this.spinTl) {
                        const currentRotation = gsap.getProperty(this.cursor, 'rotation');
                        const normalizedRotation = currentRotation % 360;
                        this.spinTl.kill();
                        this.spinTl = gsap.timeline({ repeat: -1 })
                            .to(this.cursor, { rotation: '+=360', duration: this.spinDuration, ease: 'none' });
                        
                        gsap.to(this.cursor, {
                            rotation: normalizedRotation + 360,
                            duration: this.spinDuration * (1 - normalizedRotation / 360),
                            ease: 'none',
                            onComplete: () => {
                                this.spinTl?.restart();
                            }
                        });
                    }
                    this.resumeTimeout = null;
                }, 50);
                
                this.cleanupTarget(target);
            };
            
            this.currentLeaveHandler = leaveHandler;
            target.addEventListener('mouseleave', leaveHandler);
        }
        
        handleScroll() {
            if (!this.activeTarget || !this.cursor) return;
            
            const mouseX = gsap.getProperty(this.cursor, 'x');
            const mouseY = gsap.getProperty(this.cursor, 'y');
            const elementUnderMouse = document.elementFromPoint(mouseX, mouseY);
            
            const isStillOverTarget = elementUnderMouse && 
                (elementUnderMouse === this.activeTarget || 
                 elementUnderMouse.closest(this.targetSelector) === this.activeTarget);
            
            if (!isStillOverTarget && this.currentLeaveHandler) {
                this.currentLeaveHandler();
            }
        }
        
        handleMouseDown() {
            if (!this.dot) return;
            gsap.to(this.dot, { scale: 0.7, duration: 0.3 });
            gsap.to(this.cursor, { scale: 0.9, duration: 0.2 });
        }
        
        handleMouseUp() {
            if (!this.dot) return;
            gsap.to(this.dot, { scale: 1, duration: 0.3 });
            gsap.to(this.cursor, { scale: 1, duration: 0.2 });
        }
        
        attachEventListeners() {
            window.addEventListener('mousemove', (e) => this.moveCursor(e.clientX, e.clientY));
            window.addEventListener('mouseover', (e) => this.handleEnter(e), { passive: true });
            window.addEventListener('scroll', () => this.handleScroll(), { passive: true });
            window.addEventListener('mousedown', () => this.handleMouseDown());
            window.addEventListener('mouseup', () => this.handleMouseUp());
        }
    }
    
    // Initialize Target Cursor
    if (typeof gsap !== 'undefined') {
        new TargetCursor({
            targetSelector: '.cursor-target',
            spinDuration: 2,
            hideDefaultCursor: true,
            hoverDuration: 0.2,
            parallaxOn: true
        });
    }

    // ============================================
    // Tech Stack Scroll
    // ============================================
    const container = document.getElementById('tech-scroll-container');
    const track = document.getElementById('tech-track');
    
    // Clone content enough times to fill screen and create scroll illusion
    const items = track.innerHTML;
    track.innerHTML = items + items + items + items; // 4x duplication for safety

    let scrollAmount = 0;
    const speed = 0.5; // Slightly increased for reliability
    let isHovered = false;
    let isDragging = false;
    let startX;
    let scrollLeft;
    
    // Independent accumulator for sub-pixel scrolling
    let outputScroll = 0; 

    // Auto Scroll Function
    function step() {
        // Run even if isHovered is true, only stops when strictly dragging
        if (!isDragging) {
            outputScroll += speed;
            
            // Apply to DOM
            container.scrollLeft = outputScroll;
            
            // Infinite Loop Check
            // We check if we've scrolled past 1/4 of total width (since we have 4 copies)
            // Use Math.ceil or a tolerance to ensure we don't shudder
            if (outputScroll >= track.scrollWidth / 4) {
                 outputScroll = 0;
                 container.scrollLeft = 0;
            }
        } else {
            // When dragging, sync our accumulator to the actual DOM position
            // so when we release, it continues seamlessly from there
            outputScroll = container.scrollLeft;
        }
        requestAnimationFrame(step);
    }
    
    // Start Animation
    requestAnimationFrame(step);

    // Drag to Scroll Logic
    container.addEventListener('mousedown', (e) => {
        isDragging = true;
        container.classList.add('cursor-grabbing'); // Visual feedback
        container.classList.remove('cursor-grab');
        startX = e.pageX - container.offsetLeft;
        scrollLeft = container.scrollLeft;
    });

    container.addEventListener('mouseleave', () => {
        isDragging = false;
        container.classList.remove('cursor-grabbing');
        container.classList.add('cursor-grab');
    });

    container.addEventListener('mouseup', () => {
        isDragging = false;
        container.classList.remove('cursor-grabbing');
        container.classList.add('cursor-grab');
    });

    container.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const x = e.pageX - container.offsetLeft;
        const walk = (x - startX) * 2; // Scroll-fast factor
        container.scrollLeft = scrollLeft - walk;
    });
    
    // Touch Events for Mobile
    container.addEventListener('touchstart', () => { isDragging = true; });
    container.addEventListener('touchend', () => { isDragging = false; });

    // ============================================
    // Pixel Transition Animation
    // ============================================
    class PixelTransition {
        constructor(containerId, options = {}) {
            this.container = document.getElementById(containerId);
            if (!this.container) return;

            this.firstContent = this.container.querySelector('#first-content');
            this.secondContent = this.container.querySelector('#second-content');
            this.pixelGrid = this.container.querySelector('#pixel-grid');
            
            this.gridSize = options.gridSize || 9;
            this.pixelColor = options.pixelColor || '#0A1014';
            this.animationStepDuration = options.animationStepDuration || 0.4;
            this.once = options.once || false;
            
            this.isActive = false;
            this.delayedCall = null;
            
            this.isTouchDevice = 'ontouchstart' in window || 
                                 navigator.maxTouchPoints > 0 || 
                                 window.matchMedia('(pointer: coarse)').matches;
            
            this.init();
        }
        
        init() {
            this.createPixelGrid();
            this.attachEventListeners();
        }
        
        createPixelGrid() {
            this.pixelGrid.innerHTML = '';
            
            for (let row = 0; row < this.gridSize; row++) {
                for (let col = 0; col < this.gridSize; col++) {
                    const pixel = document.createElement('div');
                    pixel.classList.add('pixel-transition__pixel');
                    pixel.style.backgroundColor = this.pixelColor;
                    
                    const size = 100 / this.gridSize;
                    pixel.style.width = `${size}%`;
                    pixel.style.height = `${size}%`;
                    pixel.style.left = `${col * size}%`;
                    pixel.style.top = `${row * size}%`;
                    pixel.style.position = 'absolute';
                    pixel.style.display = 'none';
                    
                    this.pixelGrid.appendChild(pixel);
                }
            }
        }
        
        animatePixels(activate) {
            this.isActive = activate;
            
            const pixels = this.pixelGrid.querySelectorAll('.pixel-transition__pixel');
            if (!pixels.length) return;
            
            gsap.killTweensOf(pixels);
            if (this.delayedCall) {
                this.delayedCall.kill();
            }
            
            gsap.set(pixels, { display: 'none' });
            
            const totalPixels = pixels.length;
            const staggerDuration = this.animationStepDuration / totalPixels;
            
            // First wave: pixels appear
            gsap.to(pixels, {
                display: 'block',
                duration: 0,
                stagger: {
                    each: staggerDuration,
                    from: 'random'
                }
            });
            
            // Switch content in the middle
            this.delayedCall = gsap.delayedCall(this.animationStepDuration, () => {
                if (this.secondContent) {
                    this.secondContent.style.display = activate ? 'flex' : 'none';
                }
            });
            
            // Second wave: pixels disappear
            gsap.to(pixels, {
                display: 'none',
                duration: 0,
                delay: this.animationStepDuration,
                stagger: {
                    each: staggerDuration,
                    from: 'random'
                }
            });
        }
        
        handleEnter() {
            if (!this.isActive) this.animatePixels(true);
        }
        
        handleLeave() {
            if (this.isActive && !this.once) this.animatePixels(false);
        }
        
        handleClick() {
            if (!this.isActive) {
                this.animatePixels(true);
            } else if (this.isActive && !this.once) {
                this.animatePixels(false);
            }
        }
        
        attachEventListeners() {
            if (!this.isTouchDevice) {
                this.container.addEventListener('mouseenter', () => this.handleEnter());
                this.container.addEventListener('mouseleave', () => this.handleLeave());
                this.container.addEventListener('focus', () => this.handleEnter());
                this.container.addEventListener('blur', () => this.handleLeave());
            } else {
                this.container.addEventListener('click', (e) => {
                    // Prevent navigation if clicking to toggle
                    if (!this.isActive) {
                        e.preventDefault();
                        this.handleClick();
                    }
                });
            }
        }
    }
    
    // Initialize Pixel Transition
    if (typeof gsap !== 'undefined') {
        new PixelTransition('pixel-transition-container', {
            gridSize: 9,
            pixelColor: '#0A1014',
            animationStepDuration: 0.4,
            once: false
        });
    }

    // ============================================
    // Decrypted Text Animation
    // ============================================
    class DecryptedText {
        constructor(element) {
            this.element = element;
            this.originalText = element.textContent.trim();
            this.animateOn = element.dataset.decrypt || 'view';
            this.speed = parseInt(element.dataset.decryptSpeed) || 50;
            this.maxIterations = parseInt(element.dataset.decryptIterations) || 10;
            this.sequential = element.dataset.decryptSequential === 'true';
            this.useOriginalCharsOnly = element.dataset.decryptChars === 'original';
            this.characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+';
            
            this.isAnimating = false;
            this.hasAnimated = false;
            this.revealedIndices = new Set();
            this.interval = null;
            this.currentIteration = 0;
            
            // Store original text and set initial content
            this.element.textContent = this.originalText;
            
            this.init();
        }
        
        init() {
            // Setup for hover animation
            if (this.animateOn === 'hover' || this.animateOn === 'both') {
                this.element.addEventListener('mouseenter', () => this.startAnimation());
                this.element.addEventListener('mouseleave', () => this.stopAnimation());
            }
            
            // Setup for view animation (Intersection Observer)
            if (this.animateOn === 'view' || this.animateOn === 'both') {
                let previousY = 0;
                let previousRatio = 0;
                
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const currentY = entry.boundingClientRect.y;
                        const currentRatio = entry.intersectionRatio;
                        const isIntersecting = entry.isIntersecting;
                        
                        // Detect scrolling down: element is entering viewport from bottom
                        const isScrollingDown = currentY < previousY;
                        const isBecomingVisible = currentRatio > previousRatio;
                        
                        if (isIntersecting && isScrollingDown && isBecomingVisible && !this.hasAnimated) {
                            // Small delay for smoother appearance
                            setTimeout(() => {
                                this.startAnimation();
                                this.hasAnimated = true;
                            }, 100);
                        }
                        
                        previousY = currentY;
                        previousRatio = currentRatio;
                    });
                }, {
                    threshold: [0, 0.1, 0.2, 0.3],
                    rootMargin: '0px'
                });
                
                observer.observe(this.element);
            }
        }
        
        getAvailableChars() {
            if (this.useOriginalCharsOnly) {
                return Array.from(new Set(this.originalText.split(''))).filter(char => char !== ' ');
            }
            return this.characters.split('');
        }
        
        shuffleText(currentRevealed) {
            const availableChars = this.getAvailableChars();
            
            if (this.useOriginalCharsOnly) {
                // Shuffle only unrevealed characters from original text
                const positions = this.originalText.split('').map((char, i) => ({
                    char,
                    isSpace: char === ' ',
                    index: i,
                    isRevealed: currentRevealed.has(i)
                }));
                
                const nonSpaceChars = positions
                    .filter(p => !p.isSpace && !p.isRevealed)
                    .map(p => p.char);
                
                // Fisher-Yates shuffle
                for (let i = nonSpaceChars.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [nonSpaceChars[i], nonSpaceChars[j]] = [nonSpaceChars[j], nonSpaceChars[i]];
                }
                
                let charIndex = 0;
                return positions.map(p => {
                    if (p.isSpace) return ' ';
                    if (p.isRevealed) return this.originalText[p.index];
                    return nonSpaceChars[charIndex++] || p.char;
                }).join('');
            } else {
                // Random characters
                return this.originalText.split('').map((char, i) => {
                    if (char === ' ') return ' ';
                    if (currentRevealed.has(i)) return this.originalText[i];
                    return availableChars[Math.floor(Math.random() * availableChars.length)];
                }).join('');
            }
        }
        
        startAnimation() {
            if (this.isAnimating) return;
            
            this.isAnimating = true;
            this.revealedIndices = new Set();
            this.currentIteration = 0;
            
            this.interval = setInterval(() => {
                if (this.sequential) {
                    // Sequential reveal - skip spaces
                    if (this.revealedIndices.size < this.originalText.length) {
                        let nextIndex = 0;
                        
                        // Find next unrevealed index
                        for (let i = 0; i < this.originalText.length; i++) {
                            if (!this.revealedIndices.has(i)) {
                                nextIndex = i;
                                break;
                            }
                        }
                        
                        // If it's a space, reveal it immediately and continue
                        while (nextIndex < this.originalText.length && 
                               this.originalText[nextIndex] === ' ') {
                            this.revealedIndices.add(nextIndex);
                            nextIndex++;
                        }
                        
                        if (nextIndex < this.originalText.length) {
                            this.revealedIndices.add(nextIndex);
                        }
                        
                        this.element.textContent = this.shuffleText(this.revealedIndices);
                        
                        // Check if we're done
                        if (this.revealedIndices.size >= this.originalText.length) {
                            this.stopAnimation(true);
                        }
                    } else {
                        this.stopAnimation(true);
                    }
                } else {
                    // Random scramble mode
                    this.element.textContent = this.shuffleText(this.revealedIndices);
                    this.currentIteration++;
                    
                    if (this.currentIteration >= this.maxIterations) {
                        this.stopAnimation(true);
                    }
                }
            }, this.speed);
        }
        
        stopAnimation(complete = false) {
            if (this.interval) {
                clearInterval(this.interval);
                this.interval = null;
            }
            
            if (complete || this.animateOn === 'view') {
                this.element.textContent = this.originalText;
            }
            
            if (this.animateOn === 'hover' && !complete) {
                // Reset for hover mode
                this.element.textContent = this.originalText;
                this.revealedIndices = new Set();
                this.currentIteration = 0;
            }
            
            this.isAnimating = false;
        }
    }
    
    // Initialize all decrypted text elements
    document.querySelectorAll('[data-decrypt]').forEach(element => {
        new DecryptedText(element);
    });
});